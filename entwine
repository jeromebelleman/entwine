#! /usr/bin/env python
# coding=utf-8

'''
Generate web site
'''

import sys
reload(sys)
sys.setdefaultencoding('UTF8')

import os
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import re
import StringIO
import datetime
import traceback
import shutil
import copy
import yaml
import entwine

REMETA = re.compile(r'(?:---\n(?P<meta>.*?)\n---)?(?P<body>.*)', re.DOTALL)
RETAG = re.compile(r'({{.*?}})', re.DOTALL)
REINDENT = re.compile(r'^( *)')
DATEFMT = '%d %b %Y'

HEAD0 = r'<?xml version="1.0" encoding="UTF-8"?>'
HEAD1 = r'<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">'

def applytemplate(body, inpath):
    '''
    Apply Python block template
    '''

    matches = RETAG.split(body)
    globs = {
        '__params__': {},
        'os': os,
        'loadmd': loadmd,
        'inpath': inpath,
    }
    for i, chunk in enumerate(matches):
        if chunk.startswith('{{'):
            firstline = True
            lines = []
            for line in chunk[2:-2].splitlines():
                if line:
                    if firstline:
                        indent = len(REINDENT.match(line).group(1))
                        firstline = False
                    lines.append(line[indent:])

            sys.stdout = StringIO.StringIO()
            try:
                exec('\n'.join(lines), globs) # pylint: disable=exec-used
            except Exception: # pylint: disable=broad-except
                print >> sys.stderr, \
                    '\n'.join(traceback.format_exc().splitlines()[3:])
            matches[i] = sys.stdout.getvalue()
            sys.stdout = sys.__stdout__ # pylint: disable=redefined-variable-type

    return ''.join(matches)

def sitemaps(config, outdir, dryrun):
    '''
    Write site maps
    '''

    olddirpath = os.getcwd()
    os.chdir(outdir)

    for filename in config['sitemaps']['files']:
        print "Writing %s/%s" % (os.getcwd(), filename)
        if not dryrun:
            with open(filename, 'w') as fhl:
                print >> fhl, HEAD0
                print >> fhl, HEAD1
                print >> fhl, r'  <url><loc>%s</loc></url>' % \
                    config['sitemaps']['files'][filename]
                for url in config['sitemaps']['urls']:
                    print >> fhl, r'  <url><loc>%s/%s</loc></url>' % \
                        (config['sitemaps']['files'][filename], url)
                print >> fhl, r'</urlset>'

    os.chdir(olddirpath)

def styles(config, cfgdir, dirs, dryrun):
    '''
    Write style sheet
    '''

    if 'styles' in config:
        olddirpath = os.getcwd()
        os.chdir(dirs['out'])

        inpath = cfgdir + '/' + config['styles']['in']
        outpath = config['styles']['out']

        if not os.path.lexists(outpath) or \
            entwine.getmtime(inpath) > entwine.getmtime(outpath):
            print "Writing %s/%s" % (os.getcwd(), outpath)
            if not dryrun:
                subprocess.call(['sass', inpath, outpath])

        os.chdir(olddirpath)

def latest():
    '''
    Get modification time for last-updated file
    '''

    upd = 0
    for dirpath, dirnames, filenames in os.walk('.'):
        for filename in filenames + dirnames:
            mtime = entwine.getmtime(dirpath + '/' + filename)
            upd = mtime if mtime > upd else upd

    return upd

def parsedate(date):
    '''
    Parse date
    '''

    proc = subprocess.Popen(['date', '-d', str(date), '+%s'],
                            stdout=subprocess.PIPE)
    return datetime.datetime.fromtimestamp(float(proc.communicate()[0]))

def loadmd(path):
    '''
    Load Markdown file, returning match with metadata and body
    '''

    with open(path) as fhl:
        match = REMETA.match(fhl.read())
        meta = match.group('meta')

        if meta:
            meta = yaml.load(meta)

            if 'date' in meta:
                meta['date'] = parsedate(meta['date'])

        return meta, match.group('body')

def markdown(cfgdir, # pylint: disable=too-many-locals, too-many-statements, too-many-branches, too-many-arguments
             meta, tmplmtime, indir, outdir, dirpath, infile, outfile,
             force, dryrun):
    '''
    Run Markdown (and Python beforehand)
    '''

    # Move to output directory
    olddirpath = os.getcwd()
    os.chdir(dirpath)
    dirpath = dirpath[len(outdir):]
    inpath = indir + dirpath + '/' + infile

    # Check last change in this subtree
    if not os.path.isfile(outfile) or force or \
        latest() > entwine.getmtime(outfile) or \
        tmplmtime > entwine.getmtime(outfile):

        print "Writing %s/%s" % (os.getcwd(), outfile)

        # Load Markdown file
        filemeta, body = loadmd(inpath)

        # Override defaults in metadata
        if filemeta:
            for key in filemeta:
                if key == 'options':
                    for subkey in filemeta[key]:
                        if key in meta:
                            meta[key][subkey] = filemeta[key][subkey]
                        else:
                            meta[key] = filemeta[key]
                else:
                    meta[key] = filemeta[key]

        # Write more metadata
        if meta is None:
            meta = {}
        if 'path' not in meta:
            meta['path'] = dirpath

        # Build options
        opts = []
        if 'options' in meta:
            for opt in meta['options']:
                if isinstance(meta['options'][opt], bool):
                    if meta['options'][opt]:
                        opts.append('--' + opt)
                else:
                    opts.append('--%s=%s' % (opt, meta['options'][opt]))

        # Run inline Python
        body = applytemplate(body, inpath)

        # Edit metadata for Pandoc's use of it in templates
        if 'date' in meta:
            meta['date'] = meta['date'].strftime(DATEFMT)

        # Write Pandoc temporary template
        with open(cfgdir + '/template.html') as fhlr:
            with open(cfgdir + '/template.tmp.html', 'w') as fhlw:
                fhlw.write(applytemplate(fhlr.read(), inpath))

        # Run Markdown
        proc = subprocess.Popen(['pandoc',
                                 '--template',
                                 cfgdir + '/template.tmp.html'] + \
                                opts,
                                stdin=subprocess.PIPE, stdout=subprocess.PIPE)

        out, _ = proc.communicate(yaml.dump(meta,
                                            default_flow_style=False,
                                            explicit_start=True,
                                            explicit_end=True) + body)

        # Write HTML
        if not dryrun:
            with open(outfile, 'w') as fhl:
                fhl.write(out)

    # Step back
    os.chdir(olddirpath)

def abspath(path):
    '''
    Return absolute path from user-expanded path
    '''

    return os.path.abspath(os.path.expanduser(path))

def main(): # pylint: disable=too-many-locals
    '''
    Main loop
    '''

    # Parse arguments
    parser = ArgumentParser(description="generate web site",
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('--cfgdir', '-c', help="configuration directory",
                        default='~/.entwine', type=abspath)
    parser.add_argument('--indir', '-i', help="input page directory",
                        type=os.path.expanduser)
    parser.add_argument('--outdir', '-o', help="output page directory",
                        type=os.path.expanduser)
    parser.add_argument('--dryrun', '-n',
                        help="don't write anything except directories",
                        action='store_true')
    parser.add_argument('--force', '-f',
                        help="update all files even if there's no need to",
                        action='store_true')
    args = parser.parse_args()

    # Configuration
    with open(args.cfgdir + '/entwine.yaml') as fhl:
        config = yaml.load(fhl)
    dirs = config['directories']

    # Get template modification time
    tmplmtime = entwine.getmtime(args.cfgdir + '/template.html')

    # Set input and output directories
    indir = args.indir if args.indir else abspath(dirs['in'])
    outdir = args.outdir if args.outdir else abspath(dirs['out'])

    # Compile exclude regular expression
    exclude = re.compile(config['files']['exclude'])

    # Inventory paths to sort them later on and make files and directories
    # which don't need to bear time changes.
    # It's fine to start at root because directories and static files don't
    # need to bear time changes, only templated files do.
    dirpaths = []
    for dirpath, _, filenames in os.walk(indir):

        outpath = outdir + dirpath[len(indir):]

        # Make directories
        if not os.path.lexists(outpath):
            print "Making %s/" % outpath
            os.mkdir(outpath)

        olddirpath = os.getcwd()
        os.chdir(outpath)

        # Inventory templated files and copy static files
        for filename in filenames:
            if filename == config['files']['in']:
                dirpaths.append(os.getcwd())
            else:
                inpath = dirpath + '/' + filename
                if not exclude.match(filename) and \
                    (not os.path.lexists(filename) or args.force or \
                    entwine.getmtime(inpath) > entwine.getmtime(filename)):

                    print "Copying to %s/%s" % (os.getcwd(), filename)
                    if not args.dryrun:
                        shutil.copy2(inpath, '.')

        os.chdir(olddirpath)

    # Sort paths deepest first to collect changed times, run Markdown on files
    for dirpath in sorted(dirpaths, key=lambda p: p.count('/'), reverse=True):
        markdown(args.cfgdir, copy.deepcopy(config['meta']), tmplmtime,
                 indir, outdir, dirpath,
                 config['files']['in'], config['files']['out'],
                 args.force, args.dryrun)

    # Write supporting files
    sitemaps(config, outdir, args.dryrun)
    styles(config, args.cfgdir, dirs, args.dryrun)

    # Remove Pandoc temporary template
    try:
        os.remove(args.cfgdir + '/template.tmp.html')
    except OSError:
        pass

if __name__ == '__main__':
    sys.exit(main())
